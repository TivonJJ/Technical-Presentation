# 从 Copilot 到 Agent：AI 在开发流程中的应用

## 1. 背景与目标

本次分享面向有开发背景的技术同学，包括前端、后端、测试、运维以及嵌入式开发。  
目标不是介绍 AI 的基础原理，也不是评测某一款工具，而是结合真实开发流程，探讨 AI 在当前阶段能否**切实提升工程效率**。

本次内容聚焦两个问题：
- AI 编程方式正在如何演进
- 在真实开发流程中，哪些环节已经值得引入 AI 工具

---

## 2. AI 编程方式的演进

> AI 最先、也是目前发展得最成熟的落地场景之一就是编程。  
> 实际上，AI 编程辅助在过去两年里经历了多次明显的迭代。

### 2.1 从代码补全到 Copilot

最早期的 AI 编程工具主要解决的是“少敲字”的问题，通过上下文预测完成代码补全。  
Copilot 进一步提升了对注释和函数级别语义的理解，能够生成相对完整的代码片段，但依然局限在局部上下文。

### 2.2 Vibe Coding

以 Cursor、Kiro 等工具为代表，AI 开始具备项目级上下文理解能力：
- 能跨文件修改代码
- 能理解项目结构
- 能参与重构与修复问题

这一阶段，AI 已经从“辅助输入”转变为“协作式开发”。

### 2.3 Spec Driven 开发

进一步的发展方向是 Spec Driven：
- 开发者不再描述“如何实现”
- 而是描述设计、接口、约束和目标结果
- AI 负责完成具体实现

这一模式的核心价值在于减少人与人之间的对齐成本。

> 这一部分内容可以以时间轴的形式展示，直观呈现 AI 编程方式的演进过程。

---

## 3. IDE 场景下的 AI 实践

> 代码补全、对话生成代码、需求分析、原型设计等能力，  
> 目前主流 AI IDE 工具已经可以较好地支持。
>
> 这些通用能力后续会有不同方向的同事进行更深入的分享，  
> 本部分主要聚焦一些相对“进阶”和“工程化”的使用方式。

### 3.0 使用 AI 辅助任务规划

- 将一个需求拆解为实现步骤
- 明确模块边界和实现顺序
- 辅助形成初始技术方案

该示例以功能规划为主，点到为止。

### 3.1 IDE + 设计稿 + 接口自动实现页面

在典型的 Web 开发流程中：
- 设计稿已经在 Figma 中完成
- 接口已经在 APIFox 等工具中定义

通过 AI IDE 工具，可以直接基于设计与接口上下文：
- 自动生成页面结构
- 正确调用接口
- 将代码写入现有项目中
- 页面可直接运行

该能力的价值不在于“生成速度”，而在于**减少设计、前端、后端之间的协作摩擦**。

### 3.2 Antigravity 的图形与视觉能力

Antigravity 展示了 AI 在图形与视觉方向的能力：
- 3D 效果
- 复杂视觉结构
- 快速生成可运行示例

其核心意义在于降低创意验证和探索成本。

### 3.3 从手绘草图到页面结构

通过 AI 将手绘草图逐步转化为页面：
- 草图并非标准设计稿
- AI 需要推断结构和布局
- 逐步补全细节

这一过程体现了 AI 在“从模糊想法到工程结构”中的潜力。

---

## 4. 从 IDE 走向 CLI 的必要性

尽管 IDE 场景下的 AI 能力已经相对成熟，但在真实开发中，大量问题并不发生在 IDE 内：
- 环境配置
- 服务部署
- 日志分析
- 系统运维
- 自动化脚本

这些问题更多发生在 Terminal 中。

---

## 5. CLI 形式的 AI Agent

### 5.1 CLI Agent 的特点

CLI 形式的 AI Agent 具备以下优势：
- 跨平台运行
- 可运行于远程服务器
- 可直接执行系统命令
- 更贴近真实系统状态

相较 IDE 内的 AI，CLI Agent 更强调**执行与落地能力**。

### 5.2 使用场景示例

#### 服务器环境搭建与部署
- 使用自然语言描述目标
- 自动完成 Node、Docker 等环境安装
- 部署项目并验证结果

#### 文件与资源处理
- 批量图片处理（如加水印）
- 文件整理与重命名
- 脚本自动生成与执行

#### 信息检索与内容生产
- 从网络检索多源信息
- 汇总、整理并生成完整内容
- 通过自动化流程发布至平台

CLI Agent 已逐步成为“通用执行助手”，而不仅是编码工具。

---

## 6. CLI Agent 在非开发场景中的价值

CLI Agent 的能力并不局限于开发场景：
- 文档整理
- 图片与音视频处理
- 自动化工作流
- 日常事务辅助

其核心价值在于**将重复、规则明确的事务自动化**。

---

## 7. AI 使用中的安全与隐私考量（补充）

在部分团队（如嵌入式、安全敏感业务）中，引入 AI 工具时需要重点考虑：
- 源代码是否外泄
- 数据是否离开内网
- 模型是否可控、可审计

### 7.1 本地部署模型 + 本地工具链

一种可行方案是：
- 使用本地部署的大模型（如私有推理服务）
- 搭配 Cline 等开源、本地运行的 AI 工具
- 全流程不依赖外部云服务

适用于：
- 对代码安全要求极高的场景
- 内网、离线或受限环境

### 7.2 使用受控的商业模型服务

另一种方式是使用合规性较高的商业服务：
- 例如云厂商提供的企业级模型服务（如 AWS 等）
- 明确数据边界、日志策略与合规条款
- 与现有云基础设施集成

适用于：
- 对算力和模型质量有要求
- 同时需要满足企业合规审计的团队

### 7.3 混合模式的实践建议

在实际落地中，可以采用混合策略：
- 本地 / 私有模型处理核心代码与敏感数据
- 公有模型用于通用问题、非敏感任务
- 按场景选择合适的 AI 能力，而非“一刀切”

---

## 8. 关于嵌入式开发的现状与趋势

目前 AI 对嵌入式开发的影响仍然有限，主要原因包括：
- 强依赖硬件
- 调试过程复杂
- 工程环境差异大

但随着模型在长文档理解和多模态能力上的提升，AI 已开始在以下方面体现价值：
- 阅读和总结 datasheet
- 理解硬件手册与规范
- 辅助生成配置代码与脚本
- 管理工具链和构建流程

短期内，AI 更适合作为嵌入式工程师的辅助助手，而非替代角色。

---

## 9. 对不同角色的实践建议

- 前端 / 后端：可深度使用 AI IDE 与 Agent，参与核心开发流程
- 测试 / 运维：优先关注 CLI Agent，提升自动化与排障效率
- 嵌入式：从文档处理、脚本生成等低风险场景开始引入
- 安全敏感团队：优先评估本地化或受控模型方案

---

## 10. 总结

AI 正在从“帮我们写代码”逐步演进为“帮我们把事情做完”。  
它不会取代工程师，但正在重塑工程师的工作方式。

引入 AI 不需要一步到位，可以从最重复、最耗时、最不愿意做的事情开始，让 AI 逐步进入工作流。
